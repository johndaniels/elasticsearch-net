using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Linq.Expressions;
using Elasticsearch.Net;
///This file lays the base for all the descriptors based on the query string parameters in the spec for IElasticClient.
///This file is automatically generated from https://github.com/elasticsearch/elasticsearch-rest-api-spec
///Generated of commit 

namespace Nest
{
	
	///<summary>descriptor for AbortBenchmark
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/search-benchmark.html
	///</pre>
	///</summary>
	public partial class AbortBenchmarkDescriptor  : BaseRequest<AbortBenchmarkRequestParameters>
	{
		
	
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<AbortBenchmarkRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for Bulk
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html
	///</pre>
	///</summary>
	public partial class BulkDescriptor 
	{
		
	

		///<summary>Explicit write consistency setting for the operation</summary>
		public BulkDescriptor Consistency(Consistency consistency)
		{
			this.Request.RequestParameters.Consistency(consistency);
			return this;
		}
		

		///<summary>Refresh the index after performing the operation</summary>
		public BulkDescriptor Refresh(bool refresh = true)
		{
			this.Request.RequestParameters.Refresh(refresh);
			return this;
		}
		

		///<summary>Explicitely set the replication type</summary>
		public BulkDescriptor Replication(Replication replication)
		{
			this.Request.RequestParameters.Replication(replication);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public BulkDescriptor Routing(string routing)
		{
			this.Request.RequestParameters.Routing(routing);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public BulkDescriptor Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		

		///<summary>Default document type for items which don&#39;t provide one</summary>
		public BulkDescriptor TypeQueryString(string type)
		{
			this.Request.RequestParameters.Type(type);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for CatAliases
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-aliases.html
	///</pre>
	///</summary>
	public partial class CatAliasesDescriptor  : BaseRequest<CatAliasesRequestParameters>
	{
		
	

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatAliasesDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatAliasesDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatAliasesDescriptor H(params string[] h)
		{
			this.Request.RequestParameters.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatAliasesDescriptor Help(bool help = true)
		{
			this.Request.RequestParameters.Help(help);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatAliasesDescriptor V(bool v = true)
		{
			this.Request.RequestParameters.V(v);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<CatAliasesRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for CatAllocation
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-allocation.html
	///</pre>
	///</summary>
	public partial class CatAllocationDescriptor  : BaseRequest<CatAllocationRequestParameters>
	{
		
	

		///<summary>The unit in which to display byte values</summary>
		public CatAllocationDescriptor Bytes(Bytes bytes)
		{
			this.Request.RequestParameters.Bytes(bytes);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatAllocationDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatAllocationDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatAllocationDescriptor H(params string[] h)
		{
			this.Request.RequestParameters.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatAllocationDescriptor Help(bool help = true)
		{
			this.Request.RequestParameters.Help(help);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatAllocationDescriptor V(bool v = true)
		{
			this.Request.RequestParameters.V(v);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<CatAllocationRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for CatCount
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-count.html
	///</pre>
	///</summary>
	public partial class CatCountDescriptor  : BaseRequest<CatCountRequestParameters>
	{
		
	

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatCountDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatCountDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatCountDescriptor H(params string[] h)
		{
			this.Request.RequestParameters.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatCountDescriptor Help(bool help = true)
		{
			this.Request.RequestParameters.Help(help);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatCountDescriptor V(bool v = true)
		{
			this.Request.RequestParameters.V(v);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<CatCountRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for CatFielddata
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/cat-fielddata.html
	///</pre>
	///</summary>
	public partial class CatFielddataDescriptor  : BaseRequest<CatFielddataRequestParameters>
	{
		
	

		///<summary>The unit in which to display byte values</summary>
		public CatFielddataDescriptor Bytes(Bytes bytes)
		{
			this.Request.RequestParameters.Bytes(bytes);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatFielddataDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatFielddataDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatFielddataDescriptor H(params string[] h)
		{
			this.Request.RequestParameters.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatFielddataDescriptor Help(bool help = true)
		{
			this.Request.RequestParameters.Help(help);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatFielddataDescriptor V(bool v = true)
		{
			this.Request.RequestParameters.V(v);
			return this;
		}
		

		///<summary>A comma-separated list of fields to return the fielddata size</summary>
		public CatFielddataDescriptor Fields(params string[] fields)
		{
			this.Request.RequestParameters.Fields(fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields to return the fielddata size</summary>
		public CatFielddataDescriptor Fields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters._Fields(typedPathLookups);
			return this;
		}
			
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<CatFielddataRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for CatHealth
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-health.html
	///</pre>
	///</summary>
	public partial class CatHealthDescriptor  : BaseRequest<CatHealthRequestParameters>
	{
		
	

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatHealthDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatHealthDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatHealthDescriptor H(params string[] h)
		{
			this.Request.RequestParameters.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatHealthDescriptor Help(bool help = true)
		{
			this.Request.RequestParameters.Help(help);
			return this;
		}
		

		///<summary>Set to false to disable timestamping</summary>
		public CatHealthDescriptor Ts(bool ts = true)
		{
			this.Request.RequestParameters.Ts(ts);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatHealthDescriptor V(bool v = true)
		{
			this.Request.RequestParameters.V(v);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<CatHealthRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for CatHelp
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat.html
	///</pre>
	///</summary>
	public partial class CatHelpDescriptor  : BaseRequest<CatHelpRequestParameters>
	{
		
	

		///<summary>Return help information</summary>
		public CatHelpDescriptor Help(bool help = true)
		{
			this.Request.RequestParameters.Help(help);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<CatHelpRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for CatIndices
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-indices.html
	///</pre>
	///</summary>
	public partial class CatIndicesDescriptor  : BaseRequest<CatIndicesRequestParameters>
	{
		
	

		///<summary>The unit in which to display byte values</summary>
		public CatIndicesDescriptor Bytes(Bytes bytes)
		{
			this.Request.RequestParameters.Bytes(bytes);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatIndicesDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatIndicesDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatIndicesDescriptor H(params string[] h)
		{
			this.Request.RequestParameters.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatIndicesDescriptor Help(bool help = true)
		{
			this.Request.RequestParameters.Help(help);
			return this;
		}
		

		///<summary>Set to true to return stats only for primary shards</summary>
		public CatIndicesDescriptor Pri(bool pri = true)
		{
			this.Request.RequestParameters.Pri(pri);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatIndicesDescriptor V(bool v = true)
		{
			this.Request.RequestParameters.V(v);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<CatIndicesRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for CatMaster
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-master.html
	///</pre>
	///</summary>
	public partial class CatMasterDescriptor  : BaseRequest<CatMasterRequestParameters>
	{
		
	

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatMasterDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatMasterDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatMasterDescriptor H(params string[] h)
		{
			this.Request.RequestParameters.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatMasterDescriptor Help(bool help = true)
		{
			this.Request.RequestParameters.Help(help);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatMasterDescriptor V(bool v = true)
		{
			this.Request.RequestParameters.V(v);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<CatMasterRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for CatNodes
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-nodes.html
	///</pre>
	///</summary>
	public partial class CatNodesDescriptor  : BaseRequest<CatNodesRequestParameters>
	{
		
	

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatNodesDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatNodesDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatNodesDescriptor H(params string[] h)
		{
			this.Request.RequestParameters.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatNodesDescriptor Help(bool help = true)
		{
			this.Request.RequestParameters.Help(help);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatNodesDescriptor V(bool v = true)
		{
			this.Request.RequestParameters.V(v);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<CatNodesRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for CatPendingTasks
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-pending-tasks.html
	///</pre>
	///</summary>
	public partial class CatPendingTasksDescriptor  : BaseRequest<CatPendingTasksRequestParameters>
	{
		
	

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatPendingTasksDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatPendingTasksDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatPendingTasksDescriptor H(params string[] h)
		{
			this.Request.RequestParameters.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatPendingTasksDescriptor Help(bool help = true)
		{
			this.Request.RequestParameters.Help(help);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatPendingTasksDescriptor V(bool v = true)
		{
			this.Request.RequestParameters.V(v);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<CatPendingTasksRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for CatPlugins
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/cat-plugins.html
	///</pre>
	///</summary>
	public partial class CatPluginsDescriptor  : BaseRequest<CatPluginsRequestParameters>
	{
		
	

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatPluginsDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatPluginsDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatPluginsDescriptor H(params string[] h)
		{
			this.Request.RequestParameters.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatPluginsDescriptor Help(bool help = true)
		{
			this.Request.RequestParameters.Help(help);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatPluginsDescriptor V(bool v = true)
		{
			this.Request.RequestParameters.V(v);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<CatPluginsRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for CatRecovery
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-recovery.html
	///</pre>
	///</summary>
	public partial class CatRecoveryDescriptor  : BaseRequest<CatRecoveryRequestParameters>
	{
		
	

		///<summary>The unit in which to display byte values</summary>
		public CatRecoveryDescriptor Bytes(Bytes bytes)
		{
			this.Request.RequestParameters.Bytes(bytes);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatRecoveryDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatRecoveryDescriptor H(params string[] h)
		{
			this.Request.RequestParameters.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatRecoveryDescriptor Help(bool help = true)
		{
			this.Request.RequestParameters.Help(help);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatRecoveryDescriptor V(bool v = true)
		{
			this.Request.RequestParameters.V(v);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<CatRecoveryRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for CatShards
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-shards.html
	///</pre>
	///</summary>
	public partial class CatShardsDescriptor  : BaseRequest<CatShardsRequestParameters>
	{
		
	

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatShardsDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatShardsDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatShardsDescriptor H(params string[] h)
		{
			this.Request.RequestParameters.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatShardsDescriptor Help(bool help = true)
		{
			this.Request.RequestParameters.Help(help);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatShardsDescriptor V(bool v = true)
		{
			this.Request.RequestParameters.V(v);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<CatShardsRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for CatThreadPool
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/cat-thread-pool.html
	///</pre>
	///</summary>
	public partial class CatThreadPoolDescriptor  : BaseRequest<CatThreadPoolRequestParameters>
	{
		
	

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatThreadPoolDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatThreadPoolDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatThreadPoolDescriptor H(params string[] h)
		{
			this.Request.RequestParameters.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatThreadPoolDescriptor Help(bool help = true)
		{
			this.Request.RequestParameters.Help(help);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatThreadPoolDescriptor V(bool v = true)
		{
			this.Request.RequestParameters.V(v);
			return this;
		}
		

		///<summary>Enables displaying the complete node ids</summary>
		public CatThreadPoolDescriptor FullId(bool full_id = true)
		{
			this.Request.RequestParameters.FullId(full_id);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<CatThreadPoolRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for ClearScroll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html
	///</pre>
	///</summary>
	public partial class ClearScrollDescriptor 
	{
		
	
	
	}
	
	
	///<summary>descriptor for ClusterGetSettings
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-update-settings.html
	///</pre>
	///</summary>
	public partial class ClusterGetSettingsDescriptor 
	{
		
	

		///<summary>Return settings in flat format (default: false)</summary>
		public ClusterGetSettingsDescriptor FlatSettings(bool flat_settings = true)
		{
			this.Request.RequestParameters.FlatSettings(flat_settings);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public ClusterGetSettingsDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public ClusterGetSettingsDescriptor Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for ClusterHealth
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-health.html
	///</pre>
	///</summary>
	public partial class ClusterHealthDescriptor 
	{
		
	

		///<summary>Specify the level of detail for returned information</summary>
		public ClusterHealthDescriptor Level(Level level)
		{
			this.Request.RequestParameters.Level(level);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public ClusterHealthDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public ClusterHealthDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public ClusterHealthDescriptor Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		

		///<summary>Wait until the specified number of shards is active</summary>
		public ClusterHealthDescriptor WaitForActiveShards(long wait_for_active_shards)
		{
			this.Request.RequestParameters.WaitForActiveShards(wait_for_active_shards);
			return this;
		}
		

		///<summary>Wait until the specified number of nodes is available</summary>
		public ClusterHealthDescriptor WaitForNodes(string wait_for_nodes)
		{
			this.Request.RequestParameters.WaitForNodes(wait_for_nodes);
			return this;
		}
		

		///<summary>Wait until the specified number of relocating shards is finished</summary>
		public ClusterHealthDescriptor WaitForRelocatingShards(long wait_for_relocating_shards)
		{
			this.Request.RequestParameters.WaitForRelocatingShards(wait_for_relocating_shards);
			return this;
		}
		

		///<summary>Wait until cluster is in a specific state</summary>
		public ClusterHealthDescriptor WaitForStatus(WaitForStatus wait_for_status)
		{
			this.Request.RequestParameters.WaitForStatus(wait_for_status);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for ClusterPendingTasks
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-pending.html
	///</pre>
	///</summary>
	public partial class ClusterPendingTasksDescriptor  : BaseRequest<ClusterPendingTasksRequestParameters>
	{
		
	

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public ClusterPendingTasksDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public ClusterPendingTasksDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<ClusterPendingTasksRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for ClusterPutSettings
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-update-settings.html
	///</pre>
	///</summary>
	public partial class ClusterSettingsDescriptor 
	{
		
	

		///<summary>Return settings in flat format (default: false)</summary>
		public ClusterSettingsDescriptor FlatSettings(bool flat_settings = true)
		{
			this.Request.RequestParameters.FlatSettings(flat_settings);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for ClusterReroute
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-reroute.html
	///</pre>
	///</summary>
	public partial class ClusterRerouteDescriptor  : BaseRequest<ClusterRerouteRequestParameters>
	{
		
	

		///<summary>Simulate the operation only and return the resulting state</summary>
		public ClusterRerouteDescriptor DryRun(bool dry_run = true)
		{
			this.Request.RequestParameters.DryRun(dry_run);
			return this;
		}
		

		///<summary>Return an explanation of why the commands can or cannot be executed</summary>
		public ClusterRerouteDescriptor Explain(bool explain = true)
		{
			this.Request.RequestParameters.Explain(explain);
			return this;
		}
		

		///<summary>Don&#39;t return cluster state metadata (default: false)</summary>
		public ClusterRerouteDescriptor FilterMetadata(bool filter_metadata = true)
		{
			this.Request.RequestParameters.FilterMetadata(filter_metadata);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public ClusterRerouteDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public ClusterRerouteDescriptor Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<ClusterRerouteRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for ClusterState
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-state.html
	///</pre>
	///</summary>
	public partial class ClusterStateDescriptor 
	{
		
	

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public ClusterStateDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public ClusterStateDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Return settings in flat format (default: false)</summary>
		public ClusterStateDescriptor FlatSettings(bool flat_settings = true)
		{
			this.Request.RequestParameters.FlatSettings(flat_settings);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for ClusterStats
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-stats.html
	///</pre>
	///</summary>
	public partial class ClusterStatsDescriptor  : BaseRequest<ClusterStatsRequestParameters>
	{
		
	

		///<summary>Return settings in flat format (default: false)</summary>
		public ClusterStatsDescriptor FlatSettings(bool flat_settings = true)
		{
			this.Request.RequestParameters.FlatSettings(flat_settings);
			return this;
		}
		

		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public ClusterStatsDescriptor Human(bool human = true)
		{
			this.Request.RequestParameters.Human(human);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<ClusterStatsRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for Count
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html
	///</pre>
	///</summary>
	public partial class CountDescriptor<T> 
	{
		
	

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public CountDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public CountDescriptor<T> AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public CountDescriptor<T> ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Include only documents with a specific `_score` value in the result</summary>
		public CountDescriptor<T> MinScore(double min_score)
		{
			this.Request.RequestParameters.MinScore(min_score);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public CountDescriptor<T> Preference(string preference)
		{
			this.Request.RequestParameters.Preference(preference);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public CountDescriptor<T> Routing(string routing)
		{
			this.Request.RequestParameters.Routing(routing);
			return this;
		}
		

		///<summary>The URL-encoded query definition (instead of using the request body)</summary>
		public CountDescriptor<T> Source(string source)
		{
			this.Request.RequestParameters.Source(source);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for CountPercolateGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html
	///</pre>
	///</summary>
	public partial class PercolateCountDescriptor<T> 
	{
		
	

		///<summary>A comma-separated list of specific routing values</summary>
		public PercolateCountDescriptor<T> Routing(params string[] routing)
		{
			this.Request.RequestParameters.Routing(routing);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public PercolateCountDescriptor<T> Preference(string preference)
		{
			this.Request.RequestParameters.Preference(preference);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public PercolateCountDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public PercolateCountDescriptor<T> AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public PercolateCountDescriptor<T> ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>The index to count percolate the document into. Defaults to index.</summary>
		public PercolateCountDescriptor<T> PercolateIndex(string percolate_index)
		{
			this.Request.RequestParameters.PercolateIndex(percolate_index);
			return this;
		}
		

		///<summary>The type to count percolate document into. Defaults to type.</summary>
		public PercolateCountDescriptor<T> PercolateType(string percolate_type)
		{
			this.Request.RequestParameters.PercolateType(percolate_type);
			return this;
		}
		

		///<summary>Explicit version number for concurrency control</summary>
		public PercolateCountDescriptor<T> Version(long version)
		{
			this.Request.RequestParameters.Version(version);
			return this;
		}
		

		///<summary>Specific version type</summary>
		public PercolateCountDescriptor<T> VersionType(VersionType version_type)
		{
			this.Request.RequestParameters.VersionType(version_type);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for Delete
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-delete.html
	///</pre>
	///</summary>
	public partial class DeleteDescriptor<T> 
	{
		
	

		///<summary>Specific write consistency setting for the operation</summary>
		public DeleteDescriptor<T> Consistency(Consistency consistency)
		{
			this.Request.RequestParameters.Consistency(consistency);
			return this;
		}
		

		///<summary>ID of parent document</summary>
		public DeleteDescriptor<T> Parent(string parent)
		{
			this.Request.RequestParameters.Parent(parent);
			return this;
		}
		

		///<summary>Refresh the index after performing the operation</summary>
		public DeleteDescriptor<T> Refresh(bool refresh = true)
		{
			this.Request.RequestParameters.Refresh(refresh);
			return this;
		}
		

		///<summary>Specific replication type</summary>
		public DeleteDescriptor<T> Replication(Replication replication)
		{
			this.Request.RequestParameters.Replication(replication);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public DeleteDescriptor<T> Routing(string routing)
		{
			this.Request.RequestParameters.Routing(routing);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public DeleteDescriptor<T> Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		

		///<summary>Explicit version number for concurrency control</summary>
		public DeleteDescriptor<T> Version(long version)
		{
			this.Request.RequestParameters.Version(version);
			return this;
		}
		

		///<summary>Specific version type</summary>
		public DeleteDescriptor<T> VersionType(VersionType version_type)
		{
			this.Request.RequestParameters.VersionType(version_type);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for DeleteByQuery
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-delete-by-query.html
	///</pre>
	///</summary>
	public partial class DeleteByQueryDescriptor<T> 
	{
		
	

		///<summary>The analyzer to use for the query string</summary>
		public DeleteByQueryDescriptor<T> Analyzer(string analyzer)
		{
			this.Request.RequestParameters.Analyzer(analyzer);
			return this;
		}
		

		///<summary>Specific write consistency setting for the operation</summary>
		public DeleteByQueryDescriptor<T> Consistency(Consistency consistency)
		{
			this.Request.RequestParameters.Consistency(consistency);
			return this;
		}
		

		///<summary>The default operator for query string query (AND or OR)</summary>
		public DeleteByQueryDescriptor<T> DefaultOperator(DefaultOperator default_operator)
		{
			this.Request.RequestParameters.DefaultOperator(default_operator);
			return this;
		}
		

		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public DeleteByQueryDescriptor<T> Df(string df)
		{
			this.Request.RequestParameters.Df(df);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public DeleteByQueryDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public DeleteByQueryDescriptor<T> AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public DeleteByQueryDescriptor<T> ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Specific replication type</summary>
		public DeleteByQueryDescriptor<T> Replication(Replication replication)
		{
			this.Request.RequestParameters.Replication(replication);
			return this;
		}
		

		///<summary>Query in the Lucene query string syntax</summary>
		public DeleteByQueryDescriptor<T> Q(string q)
		{
			this.Request.RequestParameters.Q(q);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public DeleteByQueryDescriptor<T> Routing(string routing)
		{
			this.Request.RequestParameters.Routing(routing);
			return this;
		}
		

		///<summary>The URL-encoded query definition (instead of using the request body)</summary>
		public DeleteByQueryDescriptor<T> Source(string source)
		{
			this.Request.RequestParameters.Source(source);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public DeleteByQueryDescriptor<T> Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for Exists
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-get.html
	///</pre>
	///</summary>
	public partial class DocumentExistsDescriptor<T> 
	{
		
	

		///<summary>The ID of the parent document</summary>
		public DocumentExistsDescriptor<T> Parent(string parent)
		{
			this.Request.RequestParameters.Parent(parent);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public DocumentExistsDescriptor<T> Preference(string preference)
		{
			this.Request.RequestParameters.Preference(preference);
			return this;
		}
		

		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public DocumentExistsDescriptor<T> Realtime(bool realtime = true)
		{
			this.Request.RequestParameters.Realtime(realtime);
			return this;
		}
		

		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public DocumentExistsDescriptor<T> Refresh(bool refresh = true)
		{
			this.Request.RequestParameters.Refresh(refresh);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public DocumentExistsDescriptor<T> Routing(string routing)
		{
			this.Request.RequestParameters.Routing(routing);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for ExplainGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-explain.html
	///</pre>
	///</summary>
	public partial class ExplainDescriptor  : BaseRequest<ExplainRequestParameters>
	{
		
	

		///<summary>Specify whether wildcards and prefix queries in the query string query should be analyzed (default: false)</summary>
		public ExplainDescriptor AnalyzeWildcard(bool analyze_wildcard = true)
		{
			this.Request.RequestParameters.AnalyzeWildcard(analyze_wildcard);
			return this;
		}
		

		///<summary>The analyzer for the query string query</summary>
		public ExplainDescriptor Analyzer(string analyzer)
		{
			this.Request.RequestParameters.Analyzer(analyzer);
			return this;
		}
		

		///<summary>The default operator for query string query (AND or OR)</summary>
		public ExplainDescriptor DefaultOperator(DefaultOperator default_operator)
		{
			this.Request.RequestParameters.DefaultOperator(default_operator);
			return this;
		}
		

		///<summary>The default field for query string query (default: _all)</summary>
		public ExplainDescriptor Df(string df)
		{
			this.Request.RequestParameters.Df(df);
			return this;
		}
		

		///<summary>A comma-separated list of fields to return in the response</summary>
		public ExplainDescriptor Fields(params string[] fields)
		{
			this.Request.RequestParameters.Fields(fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields to return in the response</summary>
		public ExplainDescriptor Fields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters._Fields(typedPathLookups);
			return this;
		}
			

		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public ExplainDescriptor Lenient(bool lenient = true)
		{
			this.Request.RequestParameters.Lenient(lenient);
			return this;
		}
		

		///<summary>Specify whether query terms should be lowercased</summary>
		public ExplainDescriptor LowercaseExpandedTerms(bool lowercase_expanded_terms = true)
		{
			this.Request.RequestParameters.LowercaseExpandedTerms(lowercase_expanded_terms);
			return this;
		}
		

		///<summary>The ID of the parent document</summary>
		public ExplainDescriptor Parent(string parent)
		{
			this.Request.RequestParameters.Parent(parent);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public ExplainDescriptor Preference(string preference)
		{
			this.Request.RequestParameters.Preference(preference);
			return this;
		}
		

		///<summary>Query in the Lucene query string syntax</summary>
		public ExplainDescriptor Q(string q)
		{
			this.Request.RequestParameters.Q(q);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public ExplainDescriptor Routing(string routing)
		{
			this.Request.RequestParameters.Routing(routing);
			return this;
		}
		

		///<summary>The URL-encoded query definition (instead of using the request body)</summary>
		public ExplainDescriptor Source(string source)
		{
			this.Request.RequestParameters.Source(source);
			return this;
		}
		

		///<summary>True or false to return the _source field or not, or a list of fields to return</summary>
		public ExplainDescriptor _Source(params string[] _source)
		{
			this.Request.RequestParameters._Source(_source);
			return this;
		}
		

		///<summary>A list of fields to exclude from the returned _source field</summary>
		public ExplainDescriptor _SourceExclude(params string[] _source_exclude)
		{
			this.Request.RequestParameters._SourceExclude(_source_exclude);
			return this;
		}
		
			
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public ExplainDescriptor _SourceExclude<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters.__SourceExclude(typedPathLookups);
			return this;
		}
			

		///<summary>A list of fields to extract and return from the _source field</summary>
		public ExplainDescriptor _SourceInclude(params string[] _source_include)
		{
			this.Request.RequestParameters._SourceInclude(_source_include);
			return this;
		}
		
			
		///<summary>A list of fields to extract and return from the _source field</summary>
		public ExplainDescriptor _SourceInclude<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters.__SourceInclude(typedPathLookups);
			return this;
		}
			
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<ExplainRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for Get
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-get.html
	///</pre>
	///</summary>
	public partial class GetDescriptor<T> 
	{
		
	

		///<summary>A comma-separated list of fields to return in the response</summary>
		public GetDescriptor<T> Fields(params string[] fields)
		{
			this.Request.RequestParameters.Fields(fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields to return in the response</summary>
		public GetDescriptor<T> Fields(params Expression<Func<T, object>>[] typedPathLookups) 
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters._Fields(typedPathLookups);
			return this;
		}
			

		///<summary>The ID of the parent document</summary>
		public GetDescriptor<T> Parent(string parent)
		{
			this.Request.RequestParameters.Parent(parent);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public GetDescriptor<T> Preference(string preference)
		{
			this.Request.RequestParameters.Preference(preference);
			return this;
		}
		

		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public GetDescriptor<T> Realtime(bool realtime = true)
		{
			this.Request.RequestParameters.Realtime(realtime);
			return this;
		}
		

		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public GetDescriptor<T> Refresh(bool refresh = true)
		{
			this.Request.RequestParameters.Refresh(refresh);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public GetDescriptor<T> Routing(string routing)
		{
			this.Request.RequestParameters.Routing(routing);
			return this;
		}
		

		///<summary>True or false to return the _source field or not, or a list of fields to return</summary>
		public GetDescriptor<T> _Source(params string[] _source)
		{
			this.Request.RequestParameters._Source(_source);
			return this;
		}
		

		///<summary>A list of fields to exclude from the returned _source field</summary>
		public GetDescriptor<T> _SourceExclude(params string[] _source_exclude)
		{
			this.Request.RequestParameters._SourceExclude(_source_exclude);
			return this;
		}
		
			
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public GetDescriptor<T> _SourceExclude(params Expression<Func<T, object>>[] typedPathLookups) 
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters.__SourceExclude(typedPathLookups);
			return this;
		}
			

		///<summary>A list of fields to extract and return from the _source field</summary>
		public GetDescriptor<T> _SourceInclude(params string[] _source_include)
		{
			this.Request.RequestParameters._SourceInclude(_source_include);
			return this;
		}
		
			
		///<summary>A list of fields to extract and return from the _source field</summary>
		public GetDescriptor<T> _SourceInclude(params Expression<Func<T, object>>[] typedPathLookups) 
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters.__SourceInclude(typedPathLookups);
			return this;
		}
			

		///<summary>Explicit version number for concurrency control</summary>
		public GetDescriptor<T> Version(long version)
		{
			this.Request.RequestParameters.Version(version);
			return this;
		}
		

		///<summary>Specific version type</summary>
		public GetDescriptor<T> VersionType(VersionType version_type)
		{
			this.Request.RequestParameters.VersionType(version_type);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for GetSource
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-get.html
	///</pre>
	///</summary>
	public partial class SourceDescriptor<T> 
	{
		
	

		///<summary>The ID of the parent document</summary>
		public SourceDescriptor<T> Parent(string parent)
		{
			this.Request.RequestParameters.Parent(parent);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SourceDescriptor<T> Preference(string preference)
		{
			this.Request.RequestParameters.Preference(preference);
			return this;
		}
		

		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public SourceDescriptor<T> Realtime(bool realtime = true)
		{
			this.Request.RequestParameters.Realtime(realtime);
			return this;
		}
		

		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public SourceDescriptor<T> Refresh(bool refresh = true)
		{
			this.Request.RequestParameters.Refresh(refresh);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public SourceDescriptor<T> Routing(string routing)
		{
			this.Request.RequestParameters.Routing(routing);
			return this;
		}
		

		///<summary>True or false to return the _source field or not, or a list of fields to return</summary>
		public SourceDescriptor<T> _Source(params string[] _source)
		{
			this.Request.RequestParameters._Source(_source);
			return this;
		}
		

		///<summary>A list of fields to exclude from the returned _source field</summary>
		public SourceDescriptor<T> _SourceExclude(params string[] _source_exclude)
		{
			this.Request.RequestParameters._SourceExclude(_source_exclude);
			return this;
		}
		
			
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public SourceDescriptor<T> _SourceExclude(params Expression<Func<T, object>>[] typedPathLookups) 
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters.__SourceExclude(typedPathLookups);
			return this;
		}
			

		///<summary>A list of fields to extract and return from the _source field</summary>
		public SourceDescriptor<T> _SourceInclude(params string[] _source_include)
		{
			this.Request.RequestParameters._SourceInclude(_source_include);
			return this;
		}
		
			
		///<summary>A list of fields to extract and return from the _source field</summary>
		public SourceDescriptor<T> _SourceInclude(params Expression<Func<T, object>>[] typedPathLookups) 
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters.__SourceInclude(typedPathLookups);
			return this;
		}
			

		///<summary>Explicit version number for concurrency control</summary>
		public SourceDescriptor<T> Version(long version)
		{
			this.Request.RequestParameters.Version(version);
			return this;
		}
		

		///<summary>Specific version type</summary>
		public SourceDescriptor<T> VersionType(VersionType version_type)
		{
			this.Request.RequestParameters.VersionType(version_type);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for Index
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-index_.html
	///</pre>
	///</summary>
	public partial class IndexDescriptor<T> 
	{
		
	

		///<summary>Explicit write consistency setting for the operation</summary>
		public IndexDescriptor<T> Consistency(Consistency consistency)
		{
			this.Request.RequestParameters.Consistency(consistency);
			return this;
		}
		

		///<summary>Explicit operation type</summary>
		public IndexDescriptor<T> OpType(OpType op_type)
		{
			this.Request.RequestParameters.OpType(op_type);
			return this;
		}
		

		///<summary>ID of the parent document</summary>
		public IndexDescriptor<T> Parent(string parent)
		{
			this.Request.RequestParameters.Parent(parent);
			return this;
		}
		

		///<summary>Refresh the index after performing the operation</summary>
		public IndexDescriptor<T> Refresh(bool refresh = true)
		{
			this.Request.RequestParameters.Refresh(refresh);
			return this;
		}
		

		///<summary>Specific replication type</summary>
		public IndexDescriptor<T> Replication(Replication replication)
		{
			this.Request.RequestParameters.Replication(replication);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public IndexDescriptor<T> Routing(string routing)
		{
			this.Request.RequestParameters.Routing(routing);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public IndexDescriptor<T> Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		

		///<summary>Explicit timestamp for the document</summary>
		public IndexDescriptor<T> Timestamp(string timestamp)
		{
			this.Request.RequestParameters.Timestamp(timestamp);
			return this;
		}
		

		///<summary>Expiration time for the document</summary>
		public IndexDescriptor<T> Ttl(string ttl)
		{
			this.Request.RequestParameters.Ttl(ttl);
			return this;
		}
		

		///<summary>Explicit version number for concurrency control</summary>
		public IndexDescriptor<T> Version(long version)
		{
			this.Request.RequestParameters.Version(version);
			return this;
		}
		

		///<summary>Specific version type</summary>
		public IndexDescriptor<T> VersionType(VersionType version_type)
		{
			this.Request.RequestParameters.VersionType(version_type);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesAnalyzeGetForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-analyze.html
	///</pre>
	///</summary>
	public partial class AnalyzeDescriptor 
	{
		
	

		///<summary>The name of the analyzer to use</summary>
		public AnalyzeDescriptor Analyzer(string analyzer)
		{
			this.Request.RequestParameters.Analyzer(analyzer);
			return this;
		}
		

		///<summary>A comma-separated list of character filters to use for the analysis</summary>
		public AnalyzeDescriptor CharFilters(params string[] char_filters)
		{
			this.Request.RequestParameters.CharFilters(char_filters);
			return this;
		}
		

		///<summary>Use the analyzer configured for this field (instead of passing the analyzer name)</summary>
		public AnalyzeDescriptor Field(string field)
		{
			this.Request.RequestParameters.Field(field);
			return this;
		}
		
			
		///<summary>Use the analyzer configured for this field (instead of passing the analyzer name)</summary>
		public AnalyzeDescriptor Field<T>(Expression<Func<T, object>> typedPathLookup) where T : class
		{
			typedPathLookup.ThrowIfNull("typedPathLookup");
			this.Request.RequestParameters._Field(typedPathLookup);
			return this;
		}
			

		///<summary>A comma-separated list of filters to use for the analysis</summary>
		public AnalyzeDescriptor Filters(params string[] filters)
		{
			this.Request.RequestParameters.Filters(filters);
			return this;
		}
		

		///<summary>The name of the index to scope the operation</summary>
		public AnalyzeDescriptor IndexQueryString(string index)
		{
			this.Request.RequestParameters.Index(index);
			return this;
		}
		

		///<summary>With `true`, specify that a local shard should be used if available, with `false`, use a random shard (default: true)</summary>
		public AnalyzeDescriptor PreferLocal(bool prefer_local = true)
		{
			this.Request.RequestParameters.PreferLocal(prefer_local);
			return this;
		}
		

		///<summary>The text on which the analysis should be performed (when request body is not used)</summary>
		public AnalyzeDescriptor Text(string text)
		{
			this.Request.RequestParameters.Text(text);
			return this;
		}
		

		///<summary>The name of the tokenizer to use for the analysis</summary>
		public AnalyzeDescriptor Tokenizer(string tokenizer)
		{
			this.Request.RequestParameters.Tokenizer(tokenizer);
			return this;
		}
		

		///<summary>Format of the output</summary>
		public AnalyzeDescriptor Format(Format format)
		{
			this.Request.RequestParameters.Format(format);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesClearCacheForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-clearcache.html
	///</pre>
	///</summary>
	public partial class ClearCacheDescriptor 
	{
		
	

		///<summary>Clear field data</summary>
		public ClearCacheDescriptor FieldData(bool field_data = true)
		{
			this.Request.RequestParameters.FieldData(field_data);
			return this;
		}
		

		///<summary>A comma-separated list of fields to clear when using the `field_data` parameter (default: all)</summary>
		public ClearCacheDescriptor Fields(params string[] fields)
		{
			this.Request.RequestParameters.Fields(fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields to clear when using the `field_data` parameter (default: all)</summary>
		public ClearCacheDescriptor Fields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters._Fields(typedPathLookups);
			return this;
		}
			

		///<summary>Clear filter caches</summary>
		public ClearCacheDescriptor Filter(bool filter = true)
		{
			this.Request.RequestParameters.Filter(filter);
			return this;
		}
		

		///<summary>Clear filter caches</summary>
		public ClearCacheDescriptor FilterCache(bool filter_cache = true)
		{
			this.Request.RequestParameters.FilterCache(filter_cache);
			return this;
		}
		

		///<summary>A comma-separated list of keys to clear when using the `filter_cache` parameter (default: all)</summary>
		public ClearCacheDescriptor FilterKeys(bool filter_keys = true)
		{
			this.Request.RequestParameters.FilterKeys(filter_keys);
			return this;
		}
		

		///<summary>Clear ID caches for parent/child</summary>
		public ClearCacheDescriptor Id(bool id = true)
		{
			this.Request.RequestParameters.Id(id);
			return this;
		}
		

		///<summary>Clear ID caches for parent/child</summary>
		public ClearCacheDescriptor IdCache(bool id_cache = true)
		{
			this.Request.RequestParameters.IdCache(id_cache);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public ClearCacheDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public ClearCacheDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ClearCacheDescriptor ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>A comma-separated list of index name to limit the operation</summary>
		public ClearCacheDescriptor IndexQueryString(params string[] index)
		{
			this.Request.RequestParameters.Index(index);
			return this;
		}
		

		///<summary>Clear the recycler cache</summary>
		public ClearCacheDescriptor Recycler(bool recycler = true)
		{
			this.Request.RequestParameters.Recycler(recycler);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesClose
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-open-close.html
	///</pre>
	///</summary>
	public partial class CloseIndexDescriptor 
	{
		
	

		///<summary>Explicit operation timeout</summary>
		public CloseIndexDescriptor Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public CloseIndexDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public CloseIndexDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public CloseIndexDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public CloseIndexDescriptor ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesCreate
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-create-index.html
	///</pre>
	///</summary>
	public partial class CreateIndexDescriptor 
	{
		
	

		///<summary>Explicit operation timeout</summary>
		public CreateIndexDescriptor Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public CreateIndexDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesDelete
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-delete-index.html
	///</pre>
	///</summary>
	public partial class DeleteIndexDescriptor 
	{
		
	

		///<summary>Explicit operation timeout</summary>
		public DeleteIndexDescriptor Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public DeleteIndexDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesDeleteAlias
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html
	///</pre>
	///</summary>
	public partial class IndicesDeleteAliasDescriptor  : BaseRequest<IndicesDeleteAliasRequestParameters>
	{
		
	

		///<summary>Explicit timestamp for the document</summary>
		public IndicesDeleteAliasDescriptor Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public IndicesDeleteAliasDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<IndicesDeleteAliasRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesDeleteMapping
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-delete-mapping.html
	///</pre>
	///</summary>
	public partial class DeleteMappingDescriptor<T> 
	{
		
	

		///<summary>Specify timeout for connection to master</summary>
		public DeleteMappingDescriptor<T> MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesDeleteTemplateForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html
	///</pre>
	///</summary>
	public partial class DeleteTemplateDescriptor 
	{
		
	

		///<summary>Explicit operation timeout</summary>
		public DeleteTemplateDescriptor Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public DeleteTemplateDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesDeleteWarmer
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html
	///</pre>
	///</summary>
	public partial class DeleteWarmerDescriptor 
	{
		
	

		///<summary>Specify timeout for connection to master</summary>
		public DeleteWarmerDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesExists
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-settings.html
	///</pre>
	///</summary>
	public partial class IndexExistsDescriptor 
	{
		
	

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public IndexExistsDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public IndexExistsDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public IndexExistsDescriptor ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public IndexExistsDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesExistsAliasForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html
	///</pre>
	///</summary>
	public partial class IndicesExistsAliasDescriptor  : BaseRequest<IndicesExistsAliasRequestParameters>
	{
		
	

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public IndicesExistsAliasDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public IndicesExistsAliasDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public IndicesExistsAliasDescriptor ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public IndicesExistsAliasDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<IndicesExistsAliasRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesExistsTemplateForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html
	///</pre>
	///</summary>
	public partial class IndicesExistsTemplateDescriptor  : BaseRequest<IndicesExistsTemplateRequestParameters>
	{
		
	

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public IndicesExistsTemplateDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<IndicesExistsTemplateRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesExistsType
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-types-exists.html
	///</pre>
	///</summary>
	public partial class IndicesExistsTypeDescriptor  : BaseRequest<IndicesExistsTypeRequestParameters>
	{
		
	

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public IndicesExistsTypeDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public IndicesExistsTypeDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public IndicesExistsTypeDescriptor ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public IndicesExistsTypeDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<IndicesExistsTypeRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesFlushForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-flush.html
	///</pre>
	///</summary>
	public partial class FlushDescriptor 
	{
		
	

		///<summary>Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal)</summary>
		public FlushDescriptor Force(bool force = true)
		{
			this.Request.RequestParameters.Force(force);
			return this;
		}
		

		///<summary>If set to true a new index writer is created and settings that have been changed related to the index writer will be refreshed. Note: if a full flush is required for a setting to take effect this will be part of the settings update process and it not required to be executed by the user. (This setting can be considered as internal)</summary>
		public FlushDescriptor Full(bool full = true)
		{
			this.Request.RequestParameters.Full(full);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public FlushDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public FlushDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public FlushDescriptor ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesGetAliasForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html
	///</pre>
	///</summary>
	public partial class GetAliasDescriptor 
	{
		
	

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetAliasDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetAliasDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetAliasDescriptor ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetAliasDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesGetAliasesForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html
	///</pre>
	///</summary>
	public partial class GetAliasesDescriptor 
	{
		
	

		///<summary>Explicit operation timeout</summary>
		public GetAliasesDescriptor Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetAliasesDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesGetFieldMappingForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-field-mapping.html
	///</pre>
	///</summary>
	public partial class IndicesGetFieldMappingDescriptor  : BaseRequest<IndicesGetFieldMappingRequestParameters>
	{
		
	

		///<summary>Whether the default mapping values should be returned as well</summary>
		public IndicesGetFieldMappingDescriptor IncludeDefaults(bool include_defaults = true)
		{
			this.Request.RequestParameters.IncludeDefaults(include_defaults);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public IndicesGetFieldMappingDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public IndicesGetFieldMappingDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public IndicesGetFieldMappingDescriptor ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public IndicesGetFieldMappingDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<IndicesGetFieldMappingRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesGetMappingForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html
	///</pre>
	///</summary>
	public partial class GetMappingDescriptor<T> 
	{
		
	

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetMappingDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetMappingDescriptor<T> AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetMappingDescriptor<T> ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetMappingDescriptor<T> Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesGetSettingsForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html
	///</pre>
	///</summary>
	public partial class GetIndexSettingsDescriptor 
	{
		
	

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetIndexSettingsDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetIndexSettingsDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetIndexSettingsDescriptor ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Return settings in flat format (default: false)</summary>
		public GetIndexSettingsDescriptor FlatSettings(bool flat_settings = true)
		{
			this.Request.RequestParameters.FlatSettings(flat_settings);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetIndexSettingsDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesGetTemplateForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html
	///</pre>
	///</summary>
	public partial class GetTemplateDescriptor 
	{
		
	

		///<summary>Return settings in flat format (default: false)</summary>
		public GetTemplateDescriptor FlatSettings(bool flat_settings = true)
		{
			this.Request.RequestParameters.FlatSettings(flat_settings);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetTemplateDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesGetWarmerForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html
	///</pre>
	///</summary>
	public partial class GetWarmerDescriptor 
	{
		
	

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetWarmerDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetWarmerDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetWarmerDescriptor ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetWarmerDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesOpen
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-open-close.html
	///</pre>
	///</summary>
	public partial class OpenIndexDescriptor 
	{
		
	

		///<summary>Explicit operation timeout</summary>
		public OpenIndexDescriptor Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public OpenIndexDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public OpenIndexDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public OpenIndexDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public OpenIndexDescriptor ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesOptimizeForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-optimize.html
	///</pre>
	///</summary>
	public partial class OptimizeDescriptor 
	{
		
	

		///<summary>Specify whether the index should be flushed after performing the operation (default: true)</summary>
		public OptimizeDescriptor Flush(bool flush = true)
		{
			this.Request.RequestParameters.Flush(flush);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public OptimizeDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public OptimizeDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public OptimizeDescriptor ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>The number of segments the index should be merged into (default: dynamic)</summary>
		public OptimizeDescriptor MaxNumSegments(long max_num_segments)
		{
			this.Request.RequestParameters.MaxNumSegments(max_num_segments);
			return this;
		}
		

		///<summary>Specify whether the operation should only expunge deleted documents</summary>
		public OptimizeDescriptor OnlyExpungeDeletes(bool only_expunge_deletes = true)
		{
			this.Request.RequestParameters.OnlyExpungeDeletes(only_expunge_deletes);
			return this;
		}
		

		///<summary>TODO: ?</summary>
		public OptimizeDescriptor OperationThreading(string operation_threading)
		{
			this.Request.RequestParameters.OperationThreading(operation_threading);
			return this;
		}
		

		///<summary>Specify whether the request should block until the merge process is finished (default: true)</summary>
		public OptimizeDescriptor WaitForMerge(bool wait_for_merge = true)
		{
			this.Request.RequestParameters.WaitForMerge(wait_for_merge);
			return this;
		}
		

		///<summary>Force a merge operation to run, even if there is a single segment in the index (default: false)</summary>
		public OptimizeDescriptor Force(bool force = true)
		{
			this.Request.RequestParameters.Force(force);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesPutAlias
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html
	///</pre>
	///</summary>
	public partial class IndicesPutAliasDescriptor  : BaseRequest<IndicesPutAliasRequestParameters>
	{
		
	

		///<summary>Explicit timestamp for the document</summary>
		public IndicesPutAliasDescriptor Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public IndicesPutAliasDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<IndicesPutAliasRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesPutMapping
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-put-mapping.html
	///</pre>
	///</summary>
	public partial class PutMappingDescriptor<T> 
	{
		
	

		///<summary>Specify whether to ignore conflicts while updating the mapping (default: false)</summary>
		public PutMappingDescriptor<T> IgnoreConflicts(bool ignore_conflicts = true)
		{
			this.Request.RequestParameters.IgnoreConflicts(ignore_conflicts);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public PutMappingDescriptor<T> Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public PutMappingDescriptor<T> MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public PutMappingDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public PutMappingDescriptor<T> AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public PutMappingDescriptor<T> ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesPutSettingsForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-update-settings.html
	///</pre>
	///</summary>
	public partial class UpdateSettingsDescriptor 
	{
		
	

		///<summary>Specify timeout for connection to master</summary>
		public UpdateSettingsDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public UpdateSettingsDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public UpdateSettingsDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public UpdateSettingsDescriptor ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Return settings in flat format (default: false)</summary>
		public UpdateSettingsDescriptor FlatSettings(bool flat_settings = true)
		{
			this.Request.RequestParameters.FlatSettings(flat_settings);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesPutTemplateForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html
	///</pre>
	///</summary>
	public partial class PutTemplateDescriptor 
	{
		
	

		///<summary>Explicit operation timeout</summary>
		public PutTemplateDescriptor Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public PutTemplateDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Return settings in flat format (default: false)</summary>
		public PutTemplateDescriptor FlatSettings(bool flat_settings = true)
		{
			this.Request.RequestParameters.FlatSettings(flat_settings);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesPutWarmerForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html
	///</pre>
	///</summary>
	public partial class PutWarmerDescriptor 
	{
		
	

		///<summary>Specify timeout for connection to master</summary>
		public PutWarmerDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed) in the search request to warm</summary>
		public PutWarmerDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices in the search request to warm. (This includes `_all` string or when no indices have been specified)</summary>
		public PutWarmerDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both, in the search request to warm.</summary>
		public PutWarmerDescriptor ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesRecoveryForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/indices-recovery.html
	///</pre>
	///</summary>
	public partial class IndicesRecoveryDescriptor  : BaseRequest<IndicesRecoveryRequestParameters>
	{
		
	

		///<summary>Whether to display detailed information about shard recovery</summary>
		public IndicesRecoveryDescriptor Detailed(bool detailed = true)
		{
			this.Request.RequestParameters.Detailed(detailed);
			return this;
		}
		

		///<summary>Display only those recoveries that are currently on-going</summary>
		public IndicesRecoveryDescriptor ActiveOnly(bool active_only = true)
		{
			this.Request.RequestParameters.ActiveOnly(active_only);
			return this;
		}
		

		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public IndicesRecoveryDescriptor Human(bool human = true)
		{
			this.Request.RequestParameters.Human(human);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<IndicesRecoveryRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesRefreshForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-refresh.html
	///</pre>
	///</summary>
	public partial class RefreshDescriptor 
	{
		
	

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public RefreshDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public RefreshDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public RefreshDescriptor ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Force a refresh even if not required</summary>
		public RefreshDescriptor Force(bool force = true)
		{
			this.Request.RequestParameters.Force(force);
			return this;
		}
		

		///<summary>TODO: ?</summary>
		public RefreshDescriptor OperationThreading(string operation_threading)
		{
			this.Request.RequestParameters.OperationThreading(operation_threading);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesSegmentsForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-segments.html
	///</pre>
	///</summary>
	public partial class SegmentsDescriptor 
	{
		
	

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SegmentsDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SegmentsDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SegmentsDescriptor ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public SegmentsDescriptor Human(bool human = true)
		{
			this.Request.RequestParameters.Human(human);
			return this;
		}
		

		///<summary>TODO: ?</summary>
		public SegmentsDescriptor OperationThreading(string operation_threading)
		{
			this.Request.RequestParameters.OperationThreading(operation_threading);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesStatsForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-stats.html
	///</pre>
	///</summary>
	public partial class IndicesStatsDescriptor 
	{
		
	

		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor CompletionFields(params string[] completion_fields)
		{
			this.Request.RequestParameters.CompletionFields(completion_fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor CompletionFields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters._CompletionFields(typedPathLookups);
			return this;
		}
			

		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor FielddataFields(params string[] fielddata_fields)
		{
			this.Request.RequestParameters.FielddataFields(fielddata_fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor FielddataFields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters._FielddataFields(typedPathLookups);
			return this;
		}
			

		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor Fields(params string[] fields)
		{
			this.Request.RequestParameters.Fields(fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor Fields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters._Fields(typedPathLookups);
			return this;
		}
			

		///<summary>A comma-separated list of search groups for `search` index metric</summary>
		public IndicesStatsDescriptor Groups(bool groups = true)
		{
			this.Request.RequestParameters.Groups(groups);
			return this;
		}
		

		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public IndicesStatsDescriptor Human(bool human = true)
		{
			this.Request.RequestParameters.Human(human);
			return this;
		}
		

		///<summary>Return stats aggregated at cluster, index or shard level</summary>
		public IndicesStatsDescriptor Level(Level level)
		{
			this.Request.RequestParameters.Level(level);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesStatusForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-status.html
	///</pre>
	///</summary>
	public partial class IndicesStatusDescriptor 
	{
		
	

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public IndicesStatusDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public IndicesStatusDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public IndicesStatusDescriptor ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public IndicesStatusDescriptor Human(bool human = true)
		{
			this.Request.RequestParameters.Human(human);
			return this;
		}
		

		///<summary>TODO: ?</summary>
		public IndicesStatusDescriptor OperationThreading(string operation_threading)
		{
			this.Request.RequestParameters.OperationThreading(operation_threading);
			return this;
		}
		

		///<summary>Return information about shard recovery</summary>
		public IndicesStatusDescriptor Recovery(bool recovery = true)
		{
			this.Request.RequestParameters.Recovery(recovery);
			return this;
		}
		

		///<summary>TODO: ?</summary>
		public IndicesStatusDescriptor Snapshot(bool snapshot = true)
		{
			this.Request.RequestParameters.Snapshot(snapshot);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesUpdateAliasesForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html
	///</pre>
	///</summary>
	public partial class AliasDescriptor 
	{
		
	

		///<summary>Request timeout</summary>
		public AliasDescriptor Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public AliasDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for IndicesValidateQueryGetForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html
	///</pre>
	///</summary>
	public partial class ValidateQueryDescriptor<T> 
	{
		
	

		///<summary>Return detailed information about the error</summary>
		public ValidateQueryDescriptor<T> Explain(bool explain = true)
		{
			this.Request.RequestParameters.Explain(explain);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public ValidateQueryDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public ValidateQueryDescriptor<T> AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ValidateQueryDescriptor<T> ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>TODO: ?</summary>
		public ValidateQueryDescriptor<T> OperationThreading(string operation_threading)
		{
			this.Request.RequestParameters.OperationThreading(operation_threading);
			return this;
		}
		

		///<summary>The URL-encoded query definition (instead of using the request body)</summary>
		public ValidateQueryDescriptor<T> Source(string source)
		{
			this.Request.RequestParameters.Source(source);
			return this;
		}
		

		///<summary>Query in the Lucene query string syntax</summary>
		public ValidateQueryDescriptor<T> Q(string q)
		{
			this.Request.RequestParameters.Q(q);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for Info
	///<pre>
	///http://www.elasticsearch.org/guide/
	///</pre>
	///</summary>
	public partial class InfoDescriptor 
	{
		
	
	
	}
	
	
	///<summary>descriptor for ListBenchmarks
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/search-benchmark.html
	///</pre>
	///</summary>
	public partial class ListBenchmarksDescriptor  : BaseRequest<ListBenchmarksRequestParameters>
	{
		
	
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<ListBenchmarksRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for MgetGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html
	///</pre>
	///</summary>
	public partial class MultiGetDescriptor 
	{
		
	

		///<summary>A comma-separated list of fields to return in the response</summary>
		public MultiGetDescriptor Fields(params string[] fields)
		{
			this.Request.RequestParameters.Fields(fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields to return in the response</summary>
		public MultiGetDescriptor Fields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters._Fields(typedPathLookups);
			return this;
		}
			

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public MultiGetDescriptor Preference(string preference)
		{
			this.Request.RequestParameters.Preference(preference);
			return this;
		}
		

		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public MultiGetDescriptor Realtime(bool realtime = true)
		{
			this.Request.RequestParameters.Realtime(realtime);
			return this;
		}
		

		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public MultiGetDescriptor Refresh(bool refresh = true)
		{
			this.Request.RequestParameters.Refresh(refresh);
			return this;
		}
		

		///<summary>True or false to return the _source field or not, or a list of fields to return</summary>
		public MultiGetDescriptor _Source(params string[] _source)
		{
			this.Request.RequestParameters._Source(_source);
			return this;
		}
		

		///<summary>A list of fields to exclude from the returned _source field</summary>
		public MultiGetDescriptor _SourceExclude(params string[] _source_exclude)
		{
			this.Request.RequestParameters._SourceExclude(_source_exclude);
			return this;
		}
		
			
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public MultiGetDescriptor _SourceExclude<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters.__SourceExclude(typedPathLookups);
			return this;
		}
			

		///<summary>A list of fields to extract and return from the _source field</summary>
		public MultiGetDescriptor _SourceInclude(params string[] _source_include)
		{
			this.Request.RequestParameters._SourceInclude(_source_include);
			return this;
		}
		
			
		///<summary>A list of fields to extract and return from the _source field</summary>
		public MultiGetDescriptor _SourceInclude<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters.__SourceInclude(typedPathLookups);
			return this;
		}
			
	
	}
	
	
	///<summary>descriptor for MltGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-more-like-this.html
	///</pre>
	///</summary>
	public partial class MoreLikeThisDescriptor<T> 
	{
		
	

		///<summary>The boost factor</summary>
		public MoreLikeThisDescriptor<T> BoostTerms(double boost_terms)
		{
			this.Request.RequestParameters.BoostTerms(boost_terms);
			return this;
		}
		

		///<summary>The word occurrence frequency as count: words with higher occurrence in the corpus will be ignored</summary>
		public MoreLikeThisDescriptor<T> MaxDocFreq(long max_doc_freq)
		{
			this.Request.RequestParameters.MaxDocFreq(max_doc_freq);
			return this;
		}
		

		///<summary>The maximum query terms to be included in the generated query</summary>
		public MoreLikeThisDescriptor<T> MaxQueryTerms(long max_query_terms)
		{
			this.Request.RequestParameters.MaxQueryTerms(max_query_terms);
			return this;
		}
		

		///<summary>The minimum length of the word: longer words will be ignored</summary>
		public MoreLikeThisDescriptor<T> MaxWordLength(long max_word_length)
		{
			this.Request.RequestParameters.MaxWordLength(max_word_length);
			return this;
		}
		

		///<summary>The word occurrence frequency as count: words with lower occurrence in the corpus will be ignored</summary>
		public MoreLikeThisDescriptor<T> MinDocFreq(long min_doc_freq)
		{
			this.Request.RequestParameters.MinDocFreq(min_doc_freq);
			return this;
		}
		

		///<summary>The term frequency as percent: terms with lower occurence in the source document will be ignored</summary>
		public MoreLikeThisDescriptor<T> MinTermFreq(long min_term_freq)
		{
			this.Request.RequestParameters.MinTermFreq(min_term_freq);
			return this;
		}
		

		///<summary>The minimum length of the word: shorter words will be ignored</summary>
		public MoreLikeThisDescriptor<T> MinWordLength(long min_word_length)
		{
			this.Request.RequestParameters.MinWordLength(min_word_length);
			return this;
		}
		

		///<summary>Specific fields to perform the query against</summary>
		public MoreLikeThisDescriptor<T> MltFields(params string[] mlt_fields)
		{
			this.Request.RequestParameters.MltFields(mlt_fields);
			return this;
		}
		
			
		///<summary>Specific fields to perform the query against</summary>
		public MoreLikeThisDescriptor<T> MltFields(params Expression<Func<T, object>>[] typedPathLookups) 
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters._MltFields(typedPathLookups);
			return this;
		}
			

		///<summary>How many terms have to match in order to consider the document a match (default: 0.3)</summary>
		public MoreLikeThisDescriptor<T> PercentTermsToMatch(double percent_terms_to_match)
		{
			this.Request.RequestParameters.PercentTermsToMatch(percent_terms_to_match);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public MoreLikeThisDescriptor<T> Routing(string routing)
		{
			this.Request.RequestParameters.Routing(routing);
			return this;
		}
		

		///<summary>The offset from which to return results</summary>
		public MoreLikeThisDescriptor<T> SearchFrom(long search_from)
		{
			this.Request.RequestParameters.SearchFrom(search_from);
			return this;
		}
		

		///<summary>A comma-separated list of indices to perform the query against (default: the index containing the document)</summary>
		public MoreLikeThisDescriptor<T> SearchIndices(params string[] search_indices)
		{
			this.Request.RequestParameters.SearchIndices(search_indices);
			return this;
		}
		

		///<summary>The search query hint</summary>
		public MoreLikeThisDescriptor<T> SearchQueryHint(string search_query_hint)
		{
			this.Request.RequestParameters.SearchQueryHint(search_query_hint);
			return this;
		}
		

		///<summary>A scroll search request definition</summary>
		public MoreLikeThisDescriptor<T> SearchScroll(string search_scroll)
		{
			this.Request.RequestParameters.SearchScroll(search_scroll);
			return this;
		}
		

		///<summary>The number of documents to return (default: 10)</summary>
		public MoreLikeThisDescriptor<T> SearchSize(long search_size)
		{
			this.Request.RequestParameters.SearchSize(search_size);
			return this;
		}
		

		///<summary>A specific search request definition (instead of using the request body)</summary>
		public MoreLikeThisDescriptor<T> SearchSource(string search_source)
		{
			this.Request.RequestParameters.SearchSource(search_source);
			return this;
		}
		

		///<summary>Specific search type (eg. `dfs_then_fetch`, `count`, etc)</summary>
		public MoreLikeThisDescriptor<T> SearchType(string search_type)
		{
			this.Request.RequestParameters.SearchType(search_type);
			return this;
		}
		

		///<summary>A comma-separated list of types to perform the query against (default: the same type as the document)</summary>
		public MoreLikeThisDescriptor<T> SearchTypes(params string[] search_types)
		{
			this.Request.RequestParameters.SearchTypes(search_types);
			return this;
		}
		

		///<summary>A list of stop words to be ignored</summary>
		public MoreLikeThisDescriptor<T> StopWords(params string[] stop_words)
		{
			this.Request.RequestParameters.StopWords(stop_words);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for MpercolateGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html
	///</pre>
	///</summary>
	public partial class MpercolateDescriptor  : BaseRequest<MpercolateRequestParameters>
	{
		
	

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public MpercolateDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public MpercolateDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public MpercolateDescriptor ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<MpercolateRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for MsearchGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html
	///</pre>
	///</summary>
	public partial class MultiSearchDescriptor 
	{
		
	

		///<summary>Search operation type</summary>
		public MultiSearchDescriptor SearchType(SearchType search_type)
		{
			this.Request.RequestParameters.SearchType(search_type);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for MtermvectorsGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html
	///</pre>
	///</summary>
	public partial class MultiTermVectorsDescriptor<T> 
	{
		
	

		///<summary>Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor<T> TermStatistics(bool term_statistics = true)
		{
			this.Request.RequestParameters.TermStatistics(term_statistics);
			return this;
		}
		

		///<summary>Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor<T> FieldStatistics(bool field_statistics = true)
		{
			this.Request.RequestParameters.FieldStatistics(field_statistics);
			return this;
		}
		

		///<summary>A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor<T> Fields(params string[] fields)
		{
			this.Request.RequestParameters.Fields(fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor<T> Fields(params Expression<Func<T, object>>[] typedPathLookups) 
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters._Fields(typedPathLookups);
			return this;
		}
			

		///<summary>Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor<T> Offsets(bool offsets = true)
		{
			this.Request.RequestParameters.Offsets(offsets);
			return this;
		}
		

		///<summary>Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor<T> Positions(bool positions = true)
		{
			this.Request.RequestParameters.Positions(positions);
			return this;
		}
		

		///<summary>Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor<T> Payloads(bool payloads = true)
		{
			this.Request.RequestParameters.Payloads(payloads);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random) .Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor<T> Preference(string preference)
		{
			this.Request.RequestParameters.Preference(preference);
			return this;
		}
		

		///<summary>Specific routing value. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor<T> Routing(string routing)
		{
			this.Request.RequestParameters.Routing(routing);
			return this;
		}
		

		///<summary>Parent id of documents. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor<T> Parent(string parent)
		{
			this.Request.RequestParameters.Parent(parent);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for NodesHotThreadsForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-hot-threads.html
	///</pre>
	///</summary>
	public partial class NodesHotThreadsDescriptor  : BaseRequest<NodesHotThreadsRequestParameters>
	{
		
	

		///<summary>The interval for the second sampling of threads</summary>
		public NodesHotThreadsDescriptor Interval(string interval)
		{
			this.Request.RequestParameters.Interval(interval);
			return this;
		}
		

		///<summary>Number of samples of thread stacktrace (default: 10)</summary>
		public NodesHotThreadsDescriptor Snapshots(long snapshots)
		{
			this.Request.RequestParameters.Snapshots(snapshots);
			return this;
		}
		

		///<summary>Specify the number of threads to provide information for (default: 3)</summary>
		public NodesHotThreadsDescriptor Threads(long threads)
		{
			this.Request.RequestParameters.Threads(threads);
			return this;
		}
		

		///<summary>The type to sample (default: cpu)</summary>
		public NodesHotThreadsDescriptor ThreadType(ThreadType thread_type)
		{
			this.Request.RequestParameters.ThreadType(thread_type);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<NodesHotThreadsRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for NodesInfoForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-info.html
	///</pre>
	///</summary>
	public partial class NodesInfoDescriptor 
	{
		
	

		///<summary>Return settings in flat format (default: false)</summary>
		public NodesInfoDescriptor FlatSettings(bool flat_settings = true)
		{
			this.Request.RequestParameters.FlatSettings(flat_settings);
			return this;
		}
		

		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public NodesInfoDescriptor Human(bool human = true)
		{
			this.Request.RequestParameters.Human(human);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for NodesShutdownForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-shutdown.html
	///</pre>
	///</summary>
	public partial class NodesShutdownDescriptor  : BaseRequest<NodesShutdownRequestParameters>
	{
		
	

		///<summary>Set the delay for the operation (default: 1s)</summary>
		public NodesShutdownDescriptor Delay(string delay)
		{
			this.Request.RequestParameters.Delay(delay);
			return this;
		}
		

		///<summary>Exit the JVM as well (default: true)</summary>
		public NodesShutdownDescriptor Exit(bool exit = true)
		{
			this.Request.RequestParameters.Exit(exit);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<NodesShutdownRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for NodesStatsForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html
	///</pre>
	///</summary>
	public partial class NodesStatsDescriptor 
	{
		
	

		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor CompletionFields(params string[] completion_fields)
		{
			this.Request.RequestParameters.CompletionFields(completion_fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor CompletionFields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters._CompletionFields(typedPathLookups);
			return this;
		}
			

		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor FielddataFields(params string[] fielddata_fields)
		{
			this.Request.RequestParameters.FielddataFields(fielddata_fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor FielddataFields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters._FielddataFields(typedPathLookups);
			return this;
		}
			

		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor Fields(params string[] fields)
		{
			this.Request.RequestParameters.Fields(fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor Fields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters._Fields(typedPathLookups);
			return this;
		}
			

		///<summary>A comma-separated list of search groups for `search` index metric</summary>
		public NodesStatsDescriptor Groups(bool groups = true)
		{
			this.Request.RequestParameters.Groups(groups);
			return this;
		}
		

		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public NodesStatsDescriptor Human(bool human = true)
		{
			this.Request.RequestParameters.Human(human);
			return this;
		}
		

		///<summary>Return indices stats aggregated at node, index or shard level</summary>
		public NodesStatsDescriptor Level(Level level)
		{
			this.Request.RequestParameters.Level(level);
			return this;
		}
		

		///<summary>A comma-separated list of document types for the `indexing` index metric</summary>
		public NodesStatsDescriptor Types(params string[] types)
		{
			this.Request.RequestParameters.Types(types);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for PercolateGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html
	///</pre>
	///</summary>
	public partial class PercolateDescriptor<T> 
	{
		
	

		///<summary>A comma-separated list of specific routing values</summary>
		public PercolateDescriptor<T> Routing(params string[] routing)
		{
			this.Request.RequestParameters.Routing(routing);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public PercolateDescriptor<T> Preference(string preference)
		{
			this.Request.RequestParameters.Preference(preference);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public PercolateDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public PercolateDescriptor<T> AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public PercolateDescriptor<T> ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>The index to percolate the document into. Defaults to index.</summary>
		public PercolateDescriptor<T> PercolateIndex(string percolate_index)
		{
			this.Request.RequestParameters.PercolateIndex(percolate_index);
			return this;
		}
		

		///<summary>The type to percolate document into. Defaults to type.</summary>
		public PercolateDescriptor<T> PercolateType(string percolate_type)
		{
			this.Request.RequestParameters.PercolateType(percolate_type);
			return this;
		}
		

		///<summary>Explicit version number for concurrency control</summary>
		public PercolateDescriptor<T> Version(long version)
		{
			this.Request.RequestParameters.Version(version);
			return this;
		}
		

		///<summary>Specific version type</summary>
		public PercolateDescriptor<T> VersionType(VersionType version_type)
		{
			this.Request.RequestParameters.VersionType(version_type);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for Ping
	///<pre>
	///http://www.elasticsearch.org/guide/
	///</pre>
	///</summary>
	public partial class PingDescriptor  : BaseRequest<PingRequestParameters>
	{
		
	
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<PingRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for ScrollGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html
	///</pre>
	///</summary>
	public partial class ScrollDescriptor<T> 
	{
		
	
	
	}
	
	
	///<summary>descriptor for SearchGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html
	///</pre>
	///</summary>
	public partial class SearchDescriptor<T> 
	{
		
	

		///<summary>The analyzer to use for the query string</summary>
		public SearchDescriptor<T> Analyzer(string analyzer)
		{
			this.Request.RequestParameters.Analyzer(analyzer);
			return this;
		}
		

		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public SearchDescriptor<T> AnalyzeWildcard(bool analyze_wildcard = true)
		{
			this.Request.RequestParameters.AnalyzeWildcard(analyze_wildcard);
			return this;
		}
		

		///<summary>The default operator for query string query (AND or OR)</summary>
		public SearchDescriptor<T> DefaultOperator(DefaultOperator default_operator)
		{
			this.Request.RequestParameters.DefaultOperator(default_operator);
			return this;
		}
		

		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public SearchDescriptor<T> Df(string df)
		{
			this.Request.RequestParameters.Df(df);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SearchDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SearchDescriptor<T> AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SearchDescriptor<T> ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public SearchDescriptor<T> Lenient(bool lenient = true)
		{
			this.Request.RequestParameters.Lenient(lenient);
			return this;
		}
		

		///<summary>Specify whether query terms should be lowercased</summary>
		public SearchDescriptor<T> LowercaseExpandedTerms(bool lowercase_expanded_terms = true)
		{
			this.Request.RequestParameters.LowercaseExpandedTerms(lowercase_expanded_terms);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SearchDescriptor<T> Preference(string preference)
		{
			this.Request.RequestParameters.Preference(preference);
			return this;
		}
		

		///<summary>A comma-separated list of specific routing values</summary>
		public SearchDescriptor<T> Routing(params string[] routing)
		{
			this.Request.RequestParameters.Routing(routing);
			return this;
		}
		

		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public SearchDescriptor<T> Scroll(string scroll)
		{
			this.Request.RequestParameters.Scroll(scroll);
			return this;
		}
		

		///<summary>Search operation type</summary>
		public SearchDescriptor<T> SearchType(SearchType search_type)
		{
			this.Request.RequestParameters.SearchType(search_type);
			return this;
		}
		

		///<summary>Specific &#39;tag&#39; of the request for logging and statistical purposes</summary>
		public SearchDescriptor<T> Stats(params string[] stats)
		{
			this.Request.RequestParameters.Stats(stats);
			return this;
		}
		

		///<summary>Specify which field to use for suggestions</summary>
		public SearchDescriptor<T> SuggestField(string suggest_field)
		{
			this.Request.RequestParameters.SuggestField(suggest_field);
			return this;
		}
		
			
		///<summary>Specify which field to use for suggestions</summary>
		public SearchDescriptor<T> SuggestField(Expression<Func<T, object>> typedPathLookup) 
		{
			typedPathLookup.ThrowIfNull("typedPathLookup");
			this.Request.RequestParameters._SuggestField(typedPathLookup);
			return this;
		}
			

		///<summary>Specify suggest mode</summary>
		public SearchDescriptor<T> SuggestMode(SuggestMode suggest_mode)
		{
			this.Request.RequestParameters.SuggestMode(suggest_mode);
			return this;
		}
		

		///<summary>How many suggestions to return in response</summary>
		public SearchDescriptor<T> SuggestSize(long suggest_size)
		{
			this.Request.RequestParameters.SuggestSize(suggest_size);
			return this;
		}
		

		///<summary>The source text for which the suggestions should be returned</summary>
		public SearchDescriptor<T> SuggestText(string suggest_text)
		{
			this.Request.RequestParameters.SuggestText(suggest_text);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for SearchShardsGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/search-shards.html
	///</pre>
	///</summary>
	public partial class SearchShardsDescriptor  : BaseRequest<SearchShardsRequestParameters>
	{
		
	

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SearchShardsDescriptor Preference(string preference)
		{
			this.Request.RequestParameters.Preference(preference);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public SearchShardsDescriptor Routing(string routing)
		{
			this.Request.RequestParameters.Routing(routing);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public SearchShardsDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SearchShardsDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SearchShardsDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SearchShardsDescriptor ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<SearchShardsRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for SearchTemplateGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-template.html
	///</pre>
	///</summary>
	public partial class SearchTemplateDescriptor  : BaseRequest<SearchTemplateRequestParameters>
	{
		
	

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SearchTemplateDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SearchTemplateDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SearchTemplateDescriptor ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SearchTemplateDescriptor Preference(string preference)
		{
			this.Request.RequestParameters.Preference(preference);
			return this;
		}
		

		///<summary>A comma-separated list of specific routing values</summary>
		public SearchTemplateDescriptor Routing(params string[] routing)
		{
			this.Request.RequestParameters.Routing(routing);
			return this;
		}
		

		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public SearchTemplateDescriptor Scroll(string scroll)
		{
			this.Request.RequestParameters.Scroll(scroll);
			return this;
		}
		

		///<summary>Search operation type</summary>
		public SearchTemplateDescriptor SearchType(SearchType search_type)
		{
			this.Request.RequestParameters.SearchType(search_type);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<SearchTemplateRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for SnapshotCreate
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html
	///</pre>
	///</summary>
	public partial class SnapshotDescriptor 
	{
		
	

		///<summary>Explicit operation timeout for connection to master node</summary>
		public SnapshotDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Should this request wait until the operation has completed before returning</summary>
		public SnapshotDescriptor WaitForCompletion(bool wait_for_completion = true)
		{
			this.Request.RequestParameters.WaitForCompletion(wait_for_completion);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for SnapshotCreateRepository
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html
	///</pre>
	///</summary>
	public partial class CreateRepositoryDescriptor 
	{
		
	

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CreateRepositoryDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public CreateRepositoryDescriptor Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for SnapshotDelete
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html
	///</pre>
	///</summary>
	public partial class DeleteSnapshotDescriptor 
	{
		
	

		///<summary>Explicit operation timeout for connection to master node</summary>
		public DeleteSnapshotDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for SnapshotDeleteRepository
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html
	///</pre>
	///</summary>
	public partial class DeleteRepositoryDescriptor 
	{
		
	

		///<summary>Explicit operation timeout for connection to master node</summary>
		public DeleteRepositoryDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public DeleteRepositoryDescriptor Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for SnapshotGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html
	///</pre>
	///</summary>
	public partial class GetSnapshotDescriptor 
	{
		
	

		///<summary>Explicit operation timeout for connection to master node</summary>
		public GetSnapshotDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for SnapshotGetRepository
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html
	///</pre>
	///</summary>
	public partial class SnapshotGetRepositoryDescriptor  : BaseRequest<SnapshotGetRepositoryRequestParameters>
	{
		
	

		///<summary>Explicit operation timeout for connection to master node</summary>
		public SnapshotGetRepositoryDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public SnapshotGetRepositoryDescriptor Local(bool local = true)
		{
			this.Request.RequestParameters.Local(local);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<SnapshotGetRepositoryRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for SnapshotRestore
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html
	///</pre>
	///</summary>
	public partial class RestoreDescriptor 
	{
		
	

		///<summary>Explicit operation timeout for connection to master node</summary>
		public RestoreDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Should this request wait until the operation has completed before returning</summary>
		public RestoreDescriptor WaitForCompletion(bool wait_for_completion = true)
		{
			this.Request.RequestParameters.WaitForCompletion(wait_for_completion);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for SnapshotStatus
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/modules-snapshots.html
	///</pre>
	///</summary>
	public partial class SnapshotStatusDescriptor  : BaseRequest<SnapshotStatusRequestParameters>
	{
		
	

		///<summary>Explicit operation timeout for connection to master node</summary>
		public SnapshotStatusDescriptor MasterTimeout(string master_timeout)
		{
			this.Request.RequestParameters.MasterTimeout(master_timeout);
			return this;
		}
		
		
		protected override void UpdatePathInfo(IConnectionSettingsValues settings, ElasticsearchPathInfo<SnapshotStatusRequestParameters> pathInfo)
		{
			throw new NotImplementedException();
		}
		
	
	}
	
	
	///<summary>descriptor for Suggest
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html
	///</pre>
	///</summary>
	public partial class SuggestDescriptor<T> 
	{
		
	

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SuggestDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this.Request.RequestParameters.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SuggestDescriptor<T> AllowNoIndices(bool allow_no_indices = true)
		{
			this.Request.RequestParameters.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SuggestDescriptor<T> ExpandWildcards(ExpandWildcards expand_wildcards)
		{
			this.Request.RequestParameters.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SuggestDescriptor<T> Preference(string preference)
		{
			this.Request.RequestParameters.Preference(preference);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public SuggestDescriptor<T> Routing(string routing)
		{
			this.Request.RequestParameters.Routing(routing);
			return this;
		}
		

		///<summary>The URL-encoded request definition (instead of using request body)</summary>
		public SuggestDescriptor<T> Source(string source)
		{
			this.Request.RequestParameters.Source(source);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for TermvectorGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-termvectors.html
	///</pre>
	///</summary>
	public partial class TermvectorDescriptor<T> 
	{
		
	

		///<summary>Specifies if total term frequency and document frequency should be returned.</summary>
		public TermvectorDescriptor<T> TermStatistics(bool term_statistics = true)
		{
			this.Request.RequestParameters.TermStatistics(term_statistics);
			return this;
		}
		

		///<summary>Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.</summary>
		public TermvectorDescriptor<T> FieldStatistics(bool field_statistics = true)
		{
			this.Request.RequestParameters.FieldStatistics(field_statistics);
			return this;
		}
		

		///<summary>A comma-separated list of fields to return.</summary>
		public TermvectorDescriptor<T> Fields(params string[] fields)
		{
			this.Request.RequestParameters.Fields(fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields to return.</summary>
		public TermvectorDescriptor<T> Fields(params Expression<Func<T, object>>[] typedPathLookups) 
		{
			if (!typedPathLookups.HasAny())
				return this;

			this.Request.RequestParameters._Fields(typedPathLookups);
			return this;
		}
			

		///<summary>Specifies if term offsets should be returned.</summary>
		public TermvectorDescriptor<T> Offsets(bool offsets = true)
		{
			this.Request.RequestParameters.Offsets(offsets);
			return this;
		}
		

		///<summary>Specifies if term positions should be returned.</summary>
		public TermvectorDescriptor<T> Positions(bool positions = true)
		{
			this.Request.RequestParameters.Positions(positions);
			return this;
		}
		

		///<summary>Specifies if term payloads should be returned.</summary>
		public TermvectorDescriptor<T> Payloads(bool payloads = true)
		{
			this.Request.RequestParameters.Payloads(payloads);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random).</summary>
		public TermvectorDescriptor<T> Preference(string preference)
		{
			this.Request.RequestParameters.Preference(preference);
			return this;
		}
		

		///<summary>Specific routing value.</summary>
		public TermvectorDescriptor<T> Routing(string routing)
		{
			this.Request.RequestParameters.Routing(routing);
			return this;
		}
		

		///<summary>Parent id of documents.</summary>
		public TermvectorDescriptor<T> Parent(string parent)
		{
			this.Request.RequestParameters.Parent(parent);
			return this;
		}
		
	
	}
	
	
	///<summary>descriptor for Update
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-update.html
	///</pre>
	///</summary>
	public partial class UpdateDescriptor<TUpsert,TDocument> 
	{
		
	

		///<summary>Explicit write consistency setting for the operation</summary>
		public UpdateDescriptor<TUpsert,TDocument> Consistency(Consistency consistency)
		{
			this.Request.RequestParameters.Consistency(consistency);
			return this;
		}
		

		///<summary>The script language (default: mvel)</summary>
		public UpdateDescriptor<TUpsert,TDocument> Lang(string lang)
		{
			this.Request.RequestParameters.Lang(lang);
			return this;
		}
		

		///<summary>ID of the parent document</summary>
		public UpdateDescriptor<TUpsert,TDocument> Parent(string parent)
		{
			this.Request.RequestParameters.Parent(parent);
			return this;
		}
		

		///<summary>Refresh the index after performing the operation</summary>
		public UpdateDescriptor<TUpsert,TDocument> Refresh(bool refresh = true)
		{
			this.Request.RequestParameters.Refresh(refresh);
			return this;
		}
		

		///<summary>Specific replication type</summary>
		public UpdateDescriptor<TUpsert,TDocument> Replication(Replication replication)
		{
			this.Request.RequestParameters.Replication(replication);
			return this;
		}
		

		///<summary>Specify how many times should the operation be retried when a conflict occurs (default: 0)</summary>
		public UpdateDescriptor<TUpsert,TDocument> RetryOnConflict(long retry_on_conflict)
		{
			this.Request.RequestParameters.RetryOnConflict(retry_on_conflict);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public UpdateDescriptor<TUpsert,TDocument> Routing(string routing)
		{
			this.Request.RequestParameters.Routing(routing);
			return this;
		}
		

		///<summary>The URL-encoded script definition (instead of using request body)</summary>
		public UpdateDescriptor<TUpsert,TDocument> ScriptQueryString(string script)
		{
			this.Request.RequestParameters.Script(script);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public UpdateDescriptor<TUpsert,TDocument> Timeout(string timeout)
		{
			this.Request.RequestParameters.Timeout(timeout);
			return this;
		}
		

		///<summary>Explicit timestamp for the document</summary>
		public UpdateDescriptor<TUpsert,TDocument> Timestamp(string timestamp)
		{
			this.Request.RequestParameters.Timestamp(timestamp);
			return this;
		}
		

		///<summary>Expiration time for the document</summary>
		public UpdateDescriptor<TUpsert,TDocument> Ttl(string ttl)
		{
			this.Request.RequestParameters.Ttl(ttl);
			return this;
		}
		

		///<summary>Explicit version number for concurrency control</summary>
		public UpdateDescriptor<TUpsert,TDocument> Version(long version)
		{
			this.Request.RequestParameters.Version(version);
			return this;
		}
		

		///<summary>Specific version type</summary>
		public UpdateDescriptor<TUpsert,TDocument> VersionType(VersionType version_type)
		{
			this.Request.RequestParameters.VersionType(version_type);
			return this;
		}
		
	
	}
	
}
 